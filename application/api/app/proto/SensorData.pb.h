// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: SensorData.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_SensorData_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_SensorData_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_SensorData_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_SensorData_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[6]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_SensorData_2eproto;
namespace com {
namespace tda {
namespace sensor {
namespace protos {
class CarData;
class CarDataDefaultTypeInternal;
extern CarDataDefaultTypeInternal _CarData_default_instance_;
class GeneralData;
class GeneralDataDefaultTypeInternal;
extern GeneralDataDefaultTypeInternal _GeneralData_default_instance_;
class GeoPosition;
class GeoPositionDefaultTypeInternal;
extern GeoPositionDefaultTypeInternal _GeoPosition_default_instance_;
class Offset3D;
class Offset3DDefaultTypeInternal;
extern Offset3DDefaultTypeInternal _Offset3D_default_instance_;
class SignData;
class SignDataDefaultTypeInternal;
extern SignDataDefaultTypeInternal _SignData_default_instance_;
class Version;
class VersionDefaultTypeInternal;
extern VersionDefaultTypeInternal _Version_default_instance_;
}  // namespace protos
}  // namespace sensor
}  // namespace tda
}  // namespace com
PROTOBUF_NAMESPACE_OPEN
template<> ::com::tda::sensor::protos::CarData* Arena::CreateMaybeMessage<::com::tda::sensor::protos::CarData>(Arena*);
template<> ::com::tda::sensor::protos::GeneralData* Arena::CreateMaybeMessage<::com::tda::sensor::protos::GeneralData>(Arena*);
template<> ::com::tda::sensor::protos::GeoPosition* Arena::CreateMaybeMessage<::com::tda::sensor::protos::GeoPosition>(Arena*);
template<> ::com::tda::sensor::protos::Offset3D* Arena::CreateMaybeMessage<::com::tda::sensor::protos::Offset3D>(Arena*);
template<> ::com::tda::sensor::protos::SignData* Arena::CreateMaybeMessage<::com::tda::sensor::protos::SignData>(Arena*);
template<> ::com::tda::sensor::protos::Version* Arena::CreateMaybeMessage<::com::tda::sensor::protos::Version>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace com {
namespace tda {
namespace sensor {
namespace protos {

enum SignLocation : int {
  UnknownLocation = 0,
  LeftLocation = 1,
  RightLocation = 2,
  TopLocation = 4,
  BottomLocation = 8
};
bool SignLocation_IsValid(int value);
constexpr SignLocation SignLocation_MIN = UnknownLocation;
constexpr SignLocation SignLocation_MAX = BottomLocation;
constexpr int SignLocation_ARRAYSIZE = SignLocation_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SignLocation_descriptor();
template<typename T>
inline const std::string& SignLocation_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SignLocation>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SignLocation_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SignLocation_descriptor(), enum_t_value);
}
inline bool SignLocation_Parse(
    const std::string& name, SignLocation* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SignLocation>(
    SignLocation_descriptor(), name, value);
}
enum SignType : int {
  UnknownSign = 0,
  SpeedLimitSign = 1,
  PassingRestrictionSign = 2,
  DerestrictionSign = 3,
  StopSign = 4,
  YieldSign = 5,
  TownSign = 6,
  MotorwaySign = 7,
  MotorRoadSign = 8,
  PriorityRoadSign = 9,
  EnvironmentalZoneSign = 10,
  ResidentialAreaSign = 11
};
bool SignType_IsValid(int value);
constexpr SignType SignType_MIN = UnknownSign;
constexpr SignType SignType_MAX = ResidentialAreaSign;
constexpr int SignType_ARRAYSIZE = SignType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SignType_descriptor();
template<typename T>
inline const std::string& SignType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SignType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SignType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SignType_descriptor(), enum_t_value);
}
inline bool SignType_Parse(
    const std::string& name, SignType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SignType>(
    SignType_descriptor(), name, value);
}
// ===================================================================

class Version PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.tda.sensor.protos.Version) */ {
 public:
  inline Version() : Version(nullptr) {};
  virtual ~Version();

  Version(const Version& from);
  Version(Version&& from) noexcept
    : Version() {
    *this = ::std::move(from);
  }

  inline Version& operator=(const Version& from) {
    CopyFrom(from);
    return *this;
  }
  inline Version& operator=(Version&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Version& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Version* internal_default_instance() {
    return reinterpret_cast<const Version*>(
               &_Version_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Version& a, Version& b) {
    a.Swap(&b);
  }
  inline void Swap(Version* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Version* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Version* New() const final {
    return CreateMaybeMessage<Version>(nullptr);
  }

  Version* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Version>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Version& from);
  void MergeFrom(const Version& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Version* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.tda.sensor.protos.Version";
  }
  protected:
  explicit Version(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_SensorData_2eproto);
    return ::descriptor_table_SensorData_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMajorFieldNumber = 1,
    kMinorFieldNumber = 2,
  };
  // required uint32 Major = 1;
  bool has_major() const;
  private:
  bool _internal_has_major() const;
  public:
  void clear_major();
  ::PROTOBUF_NAMESPACE_ID::uint32 major() const;
  void set_major(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_major() const;
  void _internal_set_major(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required uint32 Minor = 2;
  bool has_minor() const;
  private:
  bool _internal_has_minor() const;
  public:
  void clear_minor();
  ::PROTOBUF_NAMESPACE_ID::uint32 minor() const;
  void set_minor(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_minor() const;
  void _internal_set_minor(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:com.tda.sensor.protos.Version)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 major_;
  ::PROTOBUF_NAMESPACE_ID::uint32 minor_;
  friend struct ::TableStruct_SensorData_2eproto;
};
// -------------------------------------------------------------------

class GeoPosition PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.tda.sensor.protos.GeoPosition) */ {
 public:
  inline GeoPosition() : GeoPosition(nullptr) {};
  virtual ~GeoPosition();

  GeoPosition(const GeoPosition& from);
  GeoPosition(GeoPosition&& from) noexcept
    : GeoPosition() {
    *this = ::std::move(from);
  }

  inline GeoPosition& operator=(const GeoPosition& from) {
    CopyFrom(from);
    return *this;
  }
  inline GeoPosition& operator=(GeoPosition&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GeoPosition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GeoPosition* internal_default_instance() {
    return reinterpret_cast<const GeoPosition*>(
               &_GeoPosition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(GeoPosition& a, GeoPosition& b) {
    a.Swap(&b);
  }
  inline void Swap(GeoPosition* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GeoPosition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GeoPosition* New() const final {
    return CreateMaybeMessage<GeoPosition>(nullptr);
  }

  GeoPosition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GeoPosition>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GeoPosition& from);
  void MergeFrom(const GeoPosition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GeoPosition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.tda.sensor.protos.GeoPosition";
  }
  protected:
  explicit GeoPosition(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_SensorData_2eproto);
    return ::descriptor_table_SensorData_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLatitudeFieldNumber = 1,
    kLongitudeFieldNumber = 2,
  };
  // required double latitude = 1;
  bool has_latitude() const;
  private:
  bool _internal_has_latitude() const;
  public:
  void clear_latitude();
  double latitude() const;
  void set_latitude(double value);
  private:
  double _internal_latitude() const;
  void _internal_set_latitude(double value);
  public:

  // required double longitude = 2;
  bool has_longitude() const;
  private:
  bool _internal_has_longitude() const;
  public:
  void clear_longitude();
  double longitude() const;
  void set_longitude(double value);
  private:
  double _internal_longitude() const;
  void _internal_set_longitude(double value);
  public:

  // @@protoc_insertion_point(class_scope:com.tda.sensor.protos.GeoPosition)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double latitude_;
  double longitude_;
  friend struct ::TableStruct_SensorData_2eproto;
};
// -------------------------------------------------------------------

class Offset3D PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.tda.sensor.protos.Offset3D) */ {
 public:
  inline Offset3D() : Offset3D(nullptr) {};
  virtual ~Offset3D();

  Offset3D(const Offset3D& from);
  Offset3D(Offset3D&& from) noexcept
    : Offset3D() {
    *this = ::std::move(from);
  }

  inline Offset3D& operator=(const Offset3D& from) {
    CopyFrom(from);
    return *this;
  }
  inline Offset3D& operator=(Offset3D&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Offset3D& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Offset3D* internal_default_instance() {
    return reinterpret_cast<const Offset3D*>(
               &_Offset3D_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Offset3D& a, Offset3D& b) {
    a.Swap(&b);
  }
  inline void Swap(Offset3D* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Offset3D* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Offset3D* New() const final {
    return CreateMaybeMessage<Offset3D>(nullptr);
  }

  Offset3D* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Offset3D>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Offset3D& from);
  void MergeFrom(const Offset3D& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Offset3D* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.tda.sensor.protos.Offset3D";
  }
  protected:
  explicit Offset3D(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_SensorData_2eproto);
    return ::descriptor_table_SensorData_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // required float x = 1;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // required float y = 2;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // required float z = 3;
  bool has_z() const;
  private:
  bool _internal_has_z() const;
  public:
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // @@protoc_insertion_point(class_scope:com.tda.sensor.protos.Offset3D)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float x_;
  float y_;
  float z_;
  friend struct ::TableStruct_SensorData_2eproto;
};
// -------------------------------------------------------------------

class SignData PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.tda.sensor.protos.SignData) */ {
 public:
  inline SignData() : SignData(nullptr) {};
  virtual ~SignData();

  SignData(const SignData& from);
  SignData(SignData&& from) noexcept
    : SignData() {
    *this = ::std::move(from);
  }

  inline SignData& operator=(const SignData& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignData& operator=(SignData&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SignData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SignData* internal_default_instance() {
    return reinterpret_cast<const SignData*>(
               &_SignData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SignData& a, SignData& b) {
    a.Swap(&b);
  }
  inline void Swap(SignData* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SignData* New() const final {
    return CreateMaybeMessage<SignData>(nullptr);
  }

  SignData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SignData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SignData& from);
  void MergeFrom(const SignData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.tda.sensor.protos.SignData";
  }
  protected:
  explicit SignData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_SensorData_2eproto);
    return ::descriptor_table_SensorData_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 1,
    kOffsetFieldNumber = 2,
    kLocationFieldNumber = 3,
    kTypeFieldNumber = 4,
    kDetectedTimeFieldNumber = 5,
  };
  // required .com.tda.sensor.protos.GeoPosition position = 1;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::com::tda::sensor::protos::GeoPosition& position() const;
  ::com::tda::sensor::protos::GeoPosition* release_position();
  ::com::tda::sensor::protos::GeoPosition* mutable_position();
  void set_allocated_position(::com::tda::sensor::protos::GeoPosition* position);
  private:
  const ::com::tda::sensor::protos::GeoPosition& _internal_position() const;
  ::com::tda::sensor::protos::GeoPosition* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::com::tda::sensor::protos::GeoPosition* position);
  ::com::tda::sensor::protos::GeoPosition* unsafe_arena_release_position();

  // required .com.tda.sensor.protos.Offset3D offset = 2;
  bool has_offset() const;
  private:
  bool _internal_has_offset() const;
  public:
  void clear_offset();
  const ::com::tda::sensor::protos::Offset3D& offset() const;
  ::com::tda::sensor::protos::Offset3D* release_offset();
  ::com::tda::sensor::protos::Offset3D* mutable_offset();
  void set_allocated_offset(::com::tda::sensor::protos::Offset3D* offset);
  private:
  const ::com::tda::sensor::protos::Offset3D& _internal_offset() const;
  ::com::tda::sensor::protos::Offset3D* _internal_mutable_offset();
  public:
  void unsafe_arena_set_allocated_offset(
      ::com::tda::sensor::protos::Offset3D* offset);
  ::com::tda::sensor::protos::Offset3D* unsafe_arena_release_offset();

  // required .com.tda.sensor.protos.SignLocation location = 3;
  bool has_location() const;
  private:
  bool _internal_has_location() const;
  public:
  void clear_location();
  ::com::tda::sensor::protos::SignLocation location() const;
  void set_location(::com::tda::sensor::protos::SignLocation value);
  private:
  ::com::tda::sensor::protos::SignLocation _internal_location() const;
  void _internal_set_location(::com::tda::sensor::protos::SignLocation value);
  public:

  // required .com.tda.sensor.protos.SignType type = 4;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::com::tda::sensor::protos::SignType type() const;
  void set_type(::com::tda::sensor::protos::SignType value);
  private:
  ::com::tda::sensor::protos::SignType _internal_type() const;
  void _internal_set_type(::com::tda::sensor::protos::SignType value);
  public:

  // required uint64 detectedTime = 5;
  bool has_detectedtime() const;
  private:
  bool _internal_has_detectedtime() const;
  public:
  void clear_detectedtime();
  ::PROTOBUF_NAMESPACE_ID::uint64 detectedtime() const;
  void set_detectedtime(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_detectedtime() const;
  void _internal_set_detectedtime(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:com.tda.sensor.protos.SignData)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::com::tda::sensor::protos::GeoPosition* position_;
  ::com::tda::sensor::protos::Offset3D* offset_;
  int location_;
  int type_;
  ::PROTOBUF_NAMESPACE_ID::uint64 detectedtime_;
  friend struct ::TableStruct_SensorData_2eproto;
};
// -------------------------------------------------------------------

class CarData PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.tda.sensor.protos.CarData) */ {
 public:
  inline CarData() : CarData(nullptr) {};
  virtual ~CarData();

  CarData(const CarData& from);
  CarData(CarData&& from) noexcept
    : CarData() {
    *this = ::std::move(from);
  }

  inline CarData& operator=(const CarData& from) {
    CopyFrom(from);
    return *this;
  }
  inline CarData& operator=(CarData&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CarData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CarData* internal_default_instance() {
    return reinterpret_cast<const CarData*>(
               &_CarData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CarData& a, CarData& b) {
    a.Swap(&b);
  }
  inline void Swap(CarData* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CarData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CarData* New() const final {
    return CreateMaybeMessage<CarData>(nullptr);
  }

  CarData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CarData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CarData& from);
  void MergeFrom(const CarData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CarData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.tda.sensor.protos.CarData";
  }
  protected:
  explicit CarData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_SensorData_2eproto);
    return ::descriptor_table_SensorData_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSoftwareVersionFieldNumber = 1,
    kMapVersionFieldNumber = 2,
    kUuidFieldNumber = 3,
    kVinFieldNumber = 4,
    kSpeedFieldNumber = 5,
  };
  // required string softwareVersion = 1;
  bool has_softwareversion() const;
  private:
  bool _internal_has_softwareversion() const;
  public:
  void clear_softwareversion();
  const std::string& softwareversion() const;
  void set_softwareversion(const std::string& value);
  void set_softwareversion(std::string&& value);
  void set_softwareversion(const char* value);
  void set_softwareversion(const char* value, size_t size);
  std::string* mutable_softwareversion();
  std::string* release_softwareversion();
  void set_allocated_softwareversion(std::string* softwareversion);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_softwareversion();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_softwareversion(
      std::string* softwareversion);
  private:
  const std::string& _internal_softwareversion() const;
  void _internal_set_softwareversion(const std::string& value);
  std::string* _internal_mutable_softwareversion();
  public:

  // required string mapVersion = 2;
  bool has_mapversion() const;
  private:
  bool _internal_has_mapversion() const;
  public:
  void clear_mapversion();
  const std::string& mapversion() const;
  void set_mapversion(const std::string& value);
  void set_mapversion(std::string&& value);
  void set_mapversion(const char* value);
  void set_mapversion(const char* value, size_t size);
  std::string* mutable_mapversion();
  std::string* release_mapversion();
  void set_allocated_mapversion(std::string* mapversion);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_mapversion();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_mapversion(
      std::string* mapversion);
  private:
  const std::string& _internal_mapversion() const;
  void _internal_set_mapversion(const std::string& value);
  std::string* _internal_mutable_mapversion();
  public:

  // required string uuid = 3;
  bool has_uuid() const;
  private:
  bool _internal_has_uuid() const;
  public:
  void clear_uuid();
  const std::string& uuid() const;
  void set_uuid(const std::string& value);
  void set_uuid(std::string&& value);
  void set_uuid(const char* value);
  void set_uuid(const char* value, size_t size);
  std::string* mutable_uuid();
  std::string* release_uuid();
  void set_allocated_uuid(std::string* uuid);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_uuid();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_uuid(
      std::string* uuid);
  private:
  const std::string& _internal_uuid() const;
  void _internal_set_uuid(const std::string& value);
  std::string* _internal_mutable_uuid();
  public:

  // required string vin = 4;
  bool has_vin() const;
  private:
  bool _internal_has_vin() const;
  public:
  void clear_vin();
  const std::string& vin() const;
  void set_vin(const std::string& value);
  void set_vin(std::string&& value);
  void set_vin(const char* value);
  void set_vin(const char* value, size_t size);
  std::string* mutable_vin();
  std::string* release_vin();
  void set_allocated_vin(std::string* vin);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_vin();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_vin(
      std::string* vin);
  private:
  const std::string& _internal_vin() const;
  void _internal_set_vin(const std::string& value);
  std::string* _internal_mutable_vin();
  public:

  // required uint32 speed = 5;
  bool has_speed() const;
  private:
  bool _internal_has_speed() const;
  public:
  void clear_speed();
  ::PROTOBUF_NAMESPACE_ID::uint32 speed() const;
  void set_speed(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_speed() const;
  void _internal_set_speed(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:com.tda.sensor.protos.CarData)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr softwareversion_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mapversion_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uuid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vin_;
  ::PROTOBUF_NAMESPACE_ID::uint32 speed_;
  friend struct ::TableStruct_SensorData_2eproto;
};
// -------------------------------------------------------------------

class GeneralData PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.tda.sensor.protos.GeneralData) */ {
 public:
  inline GeneralData() : GeneralData(nullptr) {};
  virtual ~GeneralData();

  GeneralData(const GeneralData& from);
  GeneralData(GeneralData&& from) noexcept
    : GeneralData() {
    *this = ::std::move(from);
  }

  inline GeneralData& operator=(const GeneralData& from) {
    CopyFrom(from);
    return *this;
  }
  inline GeneralData& operator=(GeneralData&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GeneralData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GeneralData* internal_default_instance() {
    return reinterpret_cast<const GeneralData*>(
               &_GeneralData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(GeneralData& a, GeneralData& b) {
    a.Swap(&b);
  }
  inline void Swap(GeneralData* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GeneralData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GeneralData* New() const final {
    return CreateMaybeMessage<GeneralData>(nullptr);
  }

  GeneralData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GeneralData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GeneralData& from);
  void MergeFrom(const GeneralData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GeneralData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.tda.sensor.protos.GeneralData";
  }
  protected:
  explicit GeneralData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_SensorData_2eproto);
    return ::descriptor_table_SensorData_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCarDataFieldNumber = 1,
    kSignDataFieldNumber = 2,
  };
  // required .com.tda.sensor.protos.CarData carData = 1;
  bool has_cardata() const;
  private:
  bool _internal_has_cardata() const;
  public:
  void clear_cardata();
  const ::com::tda::sensor::protos::CarData& cardata() const;
  ::com::tda::sensor::protos::CarData* release_cardata();
  ::com::tda::sensor::protos::CarData* mutable_cardata();
  void set_allocated_cardata(::com::tda::sensor::protos::CarData* cardata);
  private:
  const ::com::tda::sensor::protos::CarData& _internal_cardata() const;
  ::com::tda::sensor::protos::CarData* _internal_mutable_cardata();
  public:
  void unsafe_arena_set_allocated_cardata(
      ::com::tda::sensor::protos::CarData* cardata);
  ::com::tda::sensor::protos::CarData* unsafe_arena_release_cardata();

  // required .com.tda.sensor.protos.SignData signData = 2;
  bool has_signdata() const;
  private:
  bool _internal_has_signdata() const;
  public:
  void clear_signdata();
  const ::com::tda::sensor::protos::SignData& signdata() const;
  ::com::tda::sensor::protos::SignData* release_signdata();
  ::com::tda::sensor::protos::SignData* mutable_signdata();
  void set_allocated_signdata(::com::tda::sensor::protos::SignData* signdata);
  private:
  const ::com::tda::sensor::protos::SignData& _internal_signdata() const;
  ::com::tda::sensor::protos::SignData* _internal_mutable_signdata();
  public:
  void unsafe_arena_set_allocated_signdata(
      ::com::tda::sensor::protos::SignData* signdata);
  ::com::tda::sensor::protos::SignData* unsafe_arena_release_signdata();

  // @@protoc_insertion_point(class_scope:com.tda.sensor.protos.GeneralData)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::com::tda::sensor::protos::CarData* cardata_;
  ::com::tda::sensor::protos::SignData* signdata_;
  friend struct ::TableStruct_SensorData_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Version

// required uint32 Major = 1;
inline bool Version::_internal_has_major() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Version::has_major() const {
  return _internal_has_major();
}
inline void Version::clear_major() {
  major_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Version::_internal_major() const {
  return major_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Version::major() const {
  // @@protoc_insertion_point(field_get:com.tda.sensor.protos.Version.Major)
  return _internal_major();
}
inline void Version::_internal_set_major(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  major_ = value;
}
inline void Version::set_major(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_major(value);
  // @@protoc_insertion_point(field_set:com.tda.sensor.protos.Version.Major)
}

// required uint32 Minor = 2;
inline bool Version::_internal_has_minor() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Version::has_minor() const {
  return _internal_has_minor();
}
inline void Version::clear_minor() {
  minor_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Version::_internal_minor() const {
  return minor_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Version::minor() const {
  // @@protoc_insertion_point(field_get:com.tda.sensor.protos.Version.Minor)
  return _internal_minor();
}
inline void Version::_internal_set_minor(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  minor_ = value;
}
inline void Version::set_minor(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_minor(value);
  // @@protoc_insertion_point(field_set:com.tda.sensor.protos.Version.Minor)
}

// -------------------------------------------------------------------

// GeoPosition

// required double latitude = 1;
inline bool GeoPosition::_internal_has_latitude() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GeoPosition::has_latitude() const {
  return _internal_has_latitude();
}
inline void GeoPosition::clear_latitude() {
  latitude_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double GeoPosition::_internal_latitude() const {
  return latitude_;
}
inline double GeoPosition::latitude() const {
  // @@protoc_insertion_point(field_get:com.tda.sensor.protos.GeoPosition.latitude)
  return _internal_latitude();
}
inline void GeoPosition::_internal_set_latitude(double value) {
  _has_bits_[0] |= 0x00000001u;
  latitude_ = value;
}
inline void GeoPosition::set_latitude(double value) {
  _internal_set_latitude(value);
  // @@protoc_insertion_point(field_set:com.tda.sensor.protos.GeoPosition.latitude)
}

// required double longitude = 2;
inline bool GeoPosition::_internal_has_longitude() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GeoPosition::has_longitude() const {
  return _internal_has_longitude();
}
inline void GeoPosition::clear_longitude() {
  longitude_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double GeoPosition::_internal_longitude() const {
  return longitude_;
}
inline double GeoPosition::longitude() const {
  // @@protoc_insertion_point(field_get:com.tda.sensor.protos.GeoPosition.longitude)
  return _internal_longitude();
}
inline void GeoPosition::_internal_set_longitude(double value) {
  _has_bits_[0] |= 0x00000002u;
  longitude_ = value;
}
inline void GeoPosition::set_longitude(double value) {
  _internal_set_longitude(value);
  // @@protoc_insertion_point(field_set:com.tda.sensor.protos.GeoPosition.longitude)
}

// -------------------------------------------------------------------

// Offset3D

// required float x = 1;
inline bool Offset3D::_internal_has_x() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Offset3D::has_x() const {
  return _internal_has_x();
}
inline void Offset3D::clear_x() {
  x_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float Offset3D::_internal_x() const {
  return x_;
}
inline float Offset3D::x() const {
  // @@protoc_insertion_point(field_get:com.tda.sensor.protos.Offset3D.x)
  return _internal_x();
}
inline void Offset3D::_internal_set_x(float value) {
  _has_bits_[0] |= 0x00000001u;
  x_ = value;
}
inline void Offset3D::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:com.tda.sensor.protos.Offset3D.x)
}

// required float y = 2;
inline bool Offset3D::_internal_has_y() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Offset3D::has_y() const {
  return _internal_has_y();
}
inline void Offset3D::clear_y() {
  y_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float Offset3D::_internal_y() const {
  return y_;
}
inline float Offset3D::y() const {
  // @@protoc_insertion_point(field_get:com.tda.sensor.protos.Offset3D.y)
  return _internal_y();
}
inline void Offset3D::_internal_set_y(float value) {
  _has_bits_[0] |= 0x00000002u;
  y_ = value;
}
inline void Offset3D::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:com.tda.sensor.protos.Offset3D.y)
}

// required float z = 3;
inline bool Offset3D::_internal_has_z() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Offset3D::has_z() const {
  return _internal_has_z();
}
inline void Offset3D::clear_z() {
  z_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float Offset3D::_internal_z() const {
  return z_;
}
inline float Offset3D::z() const {
  // @@protoc_insertion_point(field_get:com.tda.sensor.protos.Offset3D.z)
  return _internal_z();
}
inline void Offset3D::_internal_set_z(float value) {
  _has_bits_[0] |= 0x00000004u;
  z_ = value;
}
inline void Offset3D::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:com.tda.sensor.protos.Offset3D.z)
}

// -------------------------------------------------------------------

// SignData

// required .com.tda.sensor.protos.GeoPosition position = 1;
inline bool SignData::_internal_has_position() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || position_ != nullptr);
  return value;
}
inline bool SignData::has_position() const {
  return _internal_has_position();
}
inline void SignData::clear_position() {
  if (position_ != nullptr) position_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::com::tda::sensor::protos::GeoPosition& SignData::_internal_position() const {
  const ::com::tda::sensor::protos::GeoPosition* p = position_;
  return p != nullptr ? *p : *reinterpret_cast<const ::com::tda::sensor::protos::GeoPosition*>(
      &::com::tda::sensor::protos::_GeoPosition_default_instance_);
}
inline const ::com::tda::sensor::protos::GeoPosition& SignData::position() const {
  // @@protoc_insertion_point(field_get:com.tda.sensor.protos.SignData.position)
  return _internal_position();
}
inline void SignData::unsafe_arena_set_allocated_position(
    ::com::tda::sensor::protos::GeoPosition* position) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position_);
  }
  position_ = position;
  if (position) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.tda.sensor.protos.SignData.position)
}
inline ::com::tda::sensor::protos::GeoPosition* SignData::release_position() {
  auto temp = unsafe_arena_release_position();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::com::tda::sensor::protos::GeoPosition* SignData::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:com.tda.sensor.protos.SignData.position)
  _has_bits_[0] &= ~0x00000001u;
  ::com::tda::sensor::protos::GeoPosition* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::com::tda::sensor::protos::GeoPosition* SignData::_internal_mutable_position() {
  _has_bits_[0] |= 0x00000001u;
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::tda::sensor::protos::GeoPosition>(GetArena());
    position_ = p;
  }
  return position_;
}
inline ::com::tda::sensor::protos::GeoPosition* SignData::mutable_position() {
  // @@protoc_insertion_point(field_mutable:com.tda.sensor.protos.SignData.position)
  return _internal_mutable_position();
}
inline void SignData::set_allocated_position(::com::tda::sensor::protos::GeoPosition* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:com.tda.sensor.protos.SignData.position)
}

// required .com.tda.sensor.protos.Offset3D offset = 2;
inline bool SignData::_internal_has_offset() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || offset_ != nullptr);
  return value;
}
inline bool SignData::has_offset() const {
  return _internal_has_offset();
}
inline void SignData::clear_offset() {
  if (offset_ != nullptr) offset_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::com::tda::sensor::protos::Offset3D& SignData::_internal_offset() const {
  const ::com::tda::sensor::protos::Offset3D* p = offset_;
  return p != nullptr ? *p : *reinterpret_cast<const ::com::tda::sensor::protos::Offset3D*>(
      &::com::tda::sensor::protos::_Offset3D_default_instance_);
}
inline const ::com::tda::sensor::protos::Offset3D& SignData::offset() const {
  // @@protoc_insertion_point(field_get:com.tda.sensor.protos.SignData.offset)
  return _internal_offset();
}
inline void SignData::unsafe_arena_set_allocated_offset(
    ::com::tda::sensor::protos::Offset3D* offset) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(offset_);
  }
  offset_ = offset;
  if (offset) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.tda.sensor.protos.SignData.offset)
}
inline ::com::tda::sensor::protos::Offset3D* SignData::release_offset() {
  auto temp = unsafe_arena_release_offset();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::com::tda::sensor::protos::Offset3D* SignData::unsafe_arena_release_offset() {
  // @@protoc_insertion_point(field_release:com.tda.sensor.protos.SignData.offset)
  _has_bits_[0] &= ~0x00000002u;
  ::com::tda::sensor::protos::Offset3D* temp = offset_;
  offset_ = nullptr;
  return temp;
}
inline ::com::tda::sensor::protos::Offset3D* SignData::_internal_mutable_offset() {
  _has_bits_[0] |= 0x00000002u;
  if (offset_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::tda::sensor::protos::Offset3D>(GetArena());
    offset_ = p;
  }
  return offset_;
}
inline ::com::tda::sensor::protos::Offset3D* SignData::mutable_offset() {
  // @@protoc_insertion_point(field_mutable:com.tda.sensor.protos.SignData.offset)
  return _internal_mutable_offset();
}
inline void SignData::set_allocated_offset(::com::tda::sensor::protos::Offset3D* offset) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete offset_;
  }
  if (offset) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(offset);
    if (message_arena != submessage_arena) {
      offset = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, offset, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  offset_ = offset;
  // @@protoc_insertion_point(field_set_allocated:com.tda.sensor.protos.SignData.offset)
}

// required .com.tda.sensor.protos.SignLocation location = 3;
inline bool SignData::_internal_has_location() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SignData::has_location() const {
  return _internal_has_location();
}
inline void SignData::clear_location() {
  location_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::com::tda::sensor::protos::SignLocation SignData::_internal_location() const {
  return static_cast< ::com::tda::sensor::protos::SignLocation >(location_);
}
inline ::com::tda::sensor::protos::SignLocation SignData::location() const {
  // @@protoc_insertion_point(field_get:com.tda.sensor.protos.SignData.location)
  return _internal_location();
}
inline void SignData::_internal_set_location(::com::tda::sensor::protos::SignLocation value) {
  assert(::com::tda::sensor::protos::SignLocation_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  location_ = value;
}
inline void SignData::set_location(::com::tda::sensor::protos::SignLocation value) {
  _internal_set_location(value);
  // @@protoc_insertion_point(field_set:com.tda.sensor.protos.SignData.location)
}

// required .com.tda.sensor.protos.SignType type = 4;
inline bool SignData::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SignData::has_type() const {
  return _internal_has_type();
}
inline void SignData::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::com::tda::sensor::protos::SignType SignData::_internal_type() const {
  return static_cast< ::com::tda::sensor::protos::SignType >(type_);
}
inline ::com::tda::sensor::protos::SignType SignData::type() const {
  // @@protoc_insertion_point(field_get:com.tda.sensor.protos.SignData.type)
  return _internal_type();
}
inline void SignData::_internal_set_type(::com::tda::sensor::protos::SignType value) {
  assert(::com::tda::sensor::protos::SignType_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  type_ = value;
}
inline void SignData::set_type(::com::tda::sensor::protos::SignType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:com.tda.sensor.protos.SignData.type)
}

// required uint64 detectedTime = 5;
inline bool SignData::_internal_has_detectedtime() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool SignData::has_detectedtime() const {
  return _internal_has_detectedtime();
}
inline void SignData::clear_detectedtime() {
  detectedtime_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SignData::_internal_detectedtime() const {
  return detectedtime_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SignData::detectedtime() const {
  // @@protoc_insertion_point(field_get:com.tda.sensor.protos.SignData.detectedTime)
  return _internal_detectedtime();
}
inline void SignData::_internal_set_detectedtime(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000010u;
  detectedtime_ = value;
}
inline void SignData::set_detectedtime(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_detectedtime(value);
  // @@protoc_insertion_point(field_set:com.tda.sensor.protos.SignData.detectedTime)
}

// -------------------------------------------------------------------

// CarData

// required string softwareVersion = 1;
inline bool CarData::_internal_has_softwareversion() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CarData::has_softwareversion() const {
  return _internal_has_softwareversion();
}
inline void CarData::clear_softwareversion() {
  softwareversion_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CarData::softwareversion() const {
  // @@protoc_insertion_point(field_get:com.tda.sensor.protos.CarData.softwareVersion)
  return _internal_softwareversion();
}
inline void CarData::set_softwareversion(const std::string& value) {
  _internal_set_softwareversion(value);
  // @@protoc_insertion_point(field_set:com.tda.sensor.protos.CarData.softwareVersion)
}
inline std::string* CarData::mutable_softwareversion() {
  // @@protoc_insertion_point(field_mutable:com.tda.sensor.protos.CarData.softwareVersion)
  return _internal_mutable_softwareversion();
}
inline const std::string& CarData::_internal_softwareversion() const {
  return softwareversion_.Get();
}
inline void CarData::_internal_set_softwareversion(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  softwareversion_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void CarData::set_softwareversion(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  softwareversion_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:com.tda.sensor.protos.CarData.softwareVersion)
}
inline void CarData::set_softwareversion(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  softwareversion_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:com.tda.sensor.protos.CarData.softwareVersion)
}
inline void CarData::set_softwareversion(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  softwareversion_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:com.tda.sensor.protos.CarData.softwareVersion)
}
inline std::string* CarData::_internal_mutable_softwareversion() {
  _has_bits_[0] |= 0x00000001u;
  return softwareversion_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* CarData::release_softwareversion() {
  // @@protoc_insertion_point(field_release:com.tda.sensor.protos.CarData.softwareVersion)
  if (!_internal_has_softwareversion()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return softwareversion_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CarData::set_allocated_softwareversion(std::string* softwareversion) {
  if (softwareversion != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  softwareversion_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), softwareversion,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:com.tda.sensor.protos.CarData.softwareVersion)
}
inline std::string* CarData::unsafe_arena_release_softwareversion() {
  // @@protoc_insertion_point(field_unsafe_arena_release:com.tda.sensor.protos.CarData.softwareVersion)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return softwareversion_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void CarData::unsafe_arena_set_allocated_softwareversion(
    std::string* softwareversion) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (softwareversion != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  softwareversion_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      softwareversion, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.tda.sensor.protos.CarData.softwareVersion)
}

// required string mapVersion = 2;
inline bool CarData::_internal_has_mapversion() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CarData::has_mapversion() const {
  return _internal_has_mapversion();
}
inline void CarData::clear_mapversion() {
  mapversion_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CarData::mapversion() const {
  // @@protoc_insertion_point(field_get:com.tda.sensor.protos.CarData.mapVersion)
  return _internal_mapversion();
}
inline void CarData::set_mapversion(const std::string& value) {
  _internal_set_mapversion(value);
  // @@protoc_insertion_point(field_set:com.tda.sensor.protos.CarData.mapVersion)
}
inline std::string* CarData::mutable_mapversion() {
  // @@protoc_insertion_point(field_mutable:com.tda.sensor.protos.CarData.mapVersion)
  return _internal_mutable_mapversion();
}
inline const std::string& CarData::_internal_mapversion() const {
  return mapversion_.Get();
}
inline void CarData::_internal_set_mapversion(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  mapversion_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void CarData::set_mapversion(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  mapversion_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:com.tda.sensor.protos.CarData.mapVersion)
}
inline void CarData::set_mapversion(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  mapversion_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:com.tda.sensor.protos.CarData.mapVersion)
}
inline void CarData::set_mapversion(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  mapversion_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:com.tda.sensor.protos.CarData.mapVersion)
}
inline std::string* CarData::_internal_mutable_mapversion() {
  _has_bits_[0] |= 0x00000002u;
  return mapversion_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* CarData::release_mapversion() {
  // @@protoc_insertion_point(field_release:com.tda.sensor.protos.CarData.mapVersion)
  if (!_internal_has_mapversion()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return mapversion_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CarData::set_allocated_mapversion(std::string* mapversion) {
  if (mapversion != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  mapversion_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), mapversion,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:com.tda.sensor.protos.CarData.mapVersion)
}
inline std::string* CarData::unsafe_arena_release_mapversion() {
  // @@protoc_insertion_point(field_unsafe_arena_release:com.tda.sensor.protos.CarData.mapVersion)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return mapversion_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void CarData::unsafe_arena_set_allocated_mapversion(
    std::string* mapversion) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (mapversion != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  mapversion_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      mapversion, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.tda.sensor.protos.CarData.mapVersion)
}

// required string uuid = 3;
inline bool CarData::_internal_has_uuid() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CarData::has_uuid() const {
  return _internal_has_uuid();
}
inline void CarData::clear_uuid() {
  uuid_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CarData::uuid() const {
  // @@protoc_insertion_point(field_get:com.tda.sensor.protos.CarData.uuid)
  return _internal_uuid();
}
inline void CarData::set_uuid(const std::string& value) {
  _internal_set_uuid(value);
  // @@protoc_insertion_point(field_set:com.tda.sensor.protos.CarData.uuid)
}
inline std::string* CarData::mutable_uuid() {
  // @@protoc_insertion_point(field_mutable:com.tda.sensor.protos.CarData.uuid)
  return _internal_mutable_uuid();
}
inline const std::string& CarData::_internal_uuid() const {
  return uuid_.Get();
}
inline void CarData::_internal_set_uuid(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  uuid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void CarData::set_uuid(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  uuid_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:com.tda.sensor.protos.CarData.uuid)
}
inline void CarData::set_uuid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  uuid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:com.tda.sensor.protos.CarData.uuid)
}
inline void CarData::set_uuid(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  uuid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:com.tda.sensor.protos.CarData.uuid)
}
inline std::string* CarData::_internal_mutable_uuid() {
  _has_bits_[0] |= 0x00000004u;
  return uuid_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* CarData::release_uuid() {
  // @@protoc_insertion_point(field_release:com.tda.sensor.protos.CarData.uuid)
  if (!_internal_has_uuid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return uuid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CarData::set_allocated_uuid(std::string* uuid) {
  if (uuid != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  uuid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), uuid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:com.tda.sensor.protos.CarData.uuid)
}
inline std::string* CarData::unsafe_arena_release_uuid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:com.tda.sensor.protos.CarData.uuid)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000004u;
  return uuid_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void CarData::unsafe_arena_set_allocated_uuid(
    std::string* uuid) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (uuid != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  uuid_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      uuid, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.tda.sensor.protos.CarData.uuid)
}

// required string vin = 4;
inline bool CarData::_internal_has_vin() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CarData::has_vin() const {
  return _internal_has_vin();
}
inline void CarData::clear_vin() {
  vin_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& CarData::vin() const {
  // @@protoc_insertion_point(field_get:com.tda.sensor.protos.CarData.vin)
  return _internal_vin();
}
inline void CarData::set_vin(const std::string& value) {
  _internal_set_vin(value);
  // @@protoc_insertion_point(field_set:com.tda.sensor.protos.CarData.vin)
}
inline std::string* CarData::mutable_vin() {
  // @@protoc_insertion_point(field_mutable:com.tda.sensor.protos.CarData.vin)
  return _internal_mutable_vin();
}
inline const std::string& CarData::_internal_vin() const {
  return vin_.Get();
}
inline void CarData::_internal_set_vin(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  vin_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void CarData::set_vin(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  vin_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:com.tda.sensor.protos.CarData.vin)
}
inline void CarData::set_vin(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  vin_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:com.tda.sensor.protos.CarData.vin)
}
inline void CarData::set_vin(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000008u;
  vin_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:com.tda.sensor.protos.CarData.vin)
}
inline std::string* CarData::_internal_mutable_vin() {
  _has_bits_[0] |= 0x00000008u;
  return vin_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* CarData::release_vin() {
  // @@protoc_insertion_point(field_release:com.tda.sensor.protos.CarData.vin)
  if (!_internal_has_vin()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return vin_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CarData::set_allocated_vin(std::string* vin) {
  if (vin != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  vin_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), vin,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:com.tda.sensor.protos.CarData.vin)
}
inline std::string* CarData::unsafe_arena_release_vin() {
  // @@protoc_insertion_point(field_unsafe_arena_release:com.tda.sensor.protos.CarData.vin)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000008u;
  return vin_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void CarData::unsafe_arena_set_allocated_vin(
    std::string* vin) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (vin != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  vin_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      vin, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.tda.sensor.protos.CarData.vin)
}

// required uint32 speed = 5;
inline bool CarData::_internal_has_speed() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CarData::has_speed() const {
  return _internal_has_speed();
}
inline void CarData::clear_speed() {
  speed_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CarData::_internal_speed() const {
  return speed_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CarData::speed() const {
  // @@protoc_insertion_point(field_get:com.tda.sensor.protos.CarData.speed)
  return _internal_speed();
}
inline void CarData::_internal_set_speed(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  speed_ = value;
}
inline void CarData::set_speed(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_speed(value);
  // @@protoc_insertion_point(field_set:com.tda.sensor.protos.CarData.speed)
}

// -------------------------------------------------------------------

// GeneralData

// required .com.tda.sensor.protos.CarData carData = 1;
inline bool GeneralData::_internal_has_cardata() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || cardata_ != nullptr);
  return value;
}
inline bool GeneralData::has_cardata() const {
  return _internal_has_cardata();
}
inline void GeneralData::clear_cardata() {
  if (cardata_ != nullptr) cardata_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::com::tda::sensor::protos::CarData& GeneralData::_internal_cardata() const {
  const ::com::tda::sensor::protos::CarData* p = cardata_;
  return p != nullptr ? *p : *reinterpret_cast<const ::com::tda::sensor::protos::CarData*>(
      &::com::tda::sensor::protos::_CarData_default_instance_);
}
inline const ::com::tda::sensor::protos::CarData& GeneralData::cardata() const {
  // @@protoc_insertion_point(field_get:com.tda.sensor.protos.GeneralData.carData)
  return _internal_cardata();
}
inline void GeneralData::unsafe_arena_set_allocated_cardata(
    ::com::tda::sensor::protos::CarData* cardata) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cardata_);
  }
  cardata_ = cardata;
  if (cardata) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.tda.sensor.protos.GeneralData.carData)
}
inline ::com::tda::sensor::protos::CarData* GeneralData::release_cardata() {
  auto temp = unsafe_arena_release_cardata();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::com::tda::sensor::protos::CarData* GeneralData::unsafe_arena_release_cardata() {
  // @@protoc_insertion_point(field_release:com.tda.sensor.protos.GeneralData.carData)
  _has_bits_[0] &= ~0x00000001u;
  ::com::tda::sensor::protos::CarData* temp = cardata_;
  cardata_ = nullptr;
  return temp;
}
inline ::com::tda::sensor::protos::CarData* GeneralData::_internal_mutable_cardata() {
  _has_bits_[0] |= 0x00000001u;
  if (cardata_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::tda::sensor::protos::CarData>(GetArena());
    cardata_ = p;
  }
  return cardata_;
}
inline ::com::tda::sensor::protos::CarData* GeneralData::mutable_cardata() {
  // @@protoc_insertion_point(field_mutable:com.tda.sensor.protos.GeneralData.carData)
  return _internal_mutable_cardata();
}
inline void GeneralData::set_allocated_cardata(::com::tda::sensor::protos::CarData* cardata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete cardata_;
  }
  if (cardata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(cardata);
    if (message_arena != submessage_arena) {
      cardata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cardata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  cardata_ = cardata;
  // @@protoc_insertion_point(field_set_allocated:com.tda.sensor.protos.GeneralData.carData)
}

// required .com.tda.sensor.protos.SignData signData = 2;
inline bool GeneralData::_internal_has_signdata() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || signdata_ != nullptr);
  return value;
}
inline bool GeneralData::has_signdata() const {
  return _internal_has_signdata();
}
inline void GeneralData::clear_signdata() {
  if (signdata_ != nullptr) signdata_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::com::tda::sensor::protos::SignData& GeneralData::_internal_signdata() const {
  const ::com::tda::sensor::protos::SignData* p = signdata_;
  return p != nullptr ? *p : *reinterpret_cast<const ::com::tda::sensor::protos::SignData*>(
      &::com::tda::sensor::protos::_SignData_default_instance_);
}
inline const ::com::tda::sensor::protos::SignData& GeneralData::signdata() const {
  // @@protoc_insertion_point(field_get:com.tda.sensor.protos.GeneralData.signData)
  return _internal_signdata();
}
inline void GeneralData::unsafe_arena_set_allocated_signdata(
    ::com::tda::sensor::protos::SignData* signdata) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(signdata_);
  }
  signdata_ = signdata;
  if (signdata) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.tda.sensor.protos.GeneralData.signData)
}
inline ::com::tda::sensor::protos::SignData* GeneralData::release_signdata() {
  auto temp = unsafe_arena_release_signdata();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::com::tda::sensor::protos::SignData* GeneralData::unsafe_arena_release_signdata() {
  // @@protoc_insertion_point(field_release:com.tda.sensor.protos.GeneralData.signData)
  _has_bits_[0] &= ~0x00000002u;
  ::com::tda::sensor::protos::SignData* temp = signdata_;
  signdata_ = nullptr;
  return temp;
}
inline ::com::tda::sensor::protos::SignData* GeneralData::_internal_mutable_signdata() {
  _has_bits_[0] |= 0x00000002u;
  if (signdata_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::tda::sensor::protos::SignData>(GetArena());
    signdata_ = p;
  }
  return signdata_;
}
inline ::com::tda::sensor::protos::SignData* GeneralData::mutable_signdata() {
  // @@protoc_insertion_point(field_mutable:com.tda.sensor.protos.GeneralData.signData)
  return _internal_mutable_signdata();
}
inline void GeneralData::set_allocated_signdata(::com::tda::sensor::protos::SignData* signdata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete signdata_;
  }
  if (signdata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(signdata);
    if (message_arena != submessage_arena) {
      signdata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, signdata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  signdata_ = signdata;
  // @@protoc_insertion_point(field_set_allocated:com.tda.sensor.protos.GeneralData.signData)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace sensor
}  // namespace tda
}  // namespace com

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::com::tda::sensor::protos::SignLocation> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::tda::sensor::protos::SignLocation>() {
  return ::com::tda::sensor::protos::SignLocation_descriptor();
}
template <> struct is_proto_enum< ::com::tda::sensor::protos::SignType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::tda::sensor::protos::SignType>() {
  return ::com::tda::sensor::protos::SignType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_SensorData_2eproto
